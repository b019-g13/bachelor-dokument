\cleardoublepage
\chapter{Implementasjon / Produksjon / Gjennomføring (Generisk tittel)}
\label{chap:implementation} 
\clearpage

% \meta{
% Her skal det beskrives hvordan man faktisk produserte resultatene i prosjektet, og viktigst, beskrive selve produktet. Hvilke verktøy brukte man, hvordan foregikk produksjonen, etc. Utformingen av dette kapittelet avhenger helt klart av type prosjekt.
% }

I dette kapittelet skal vi presentere resultatene i prosjektet og en beskrivelse av nettstedet. Her vil vi også presentere hvilke verktøy vi endte opp med å bruke og hvordan selve produksjonen foregikk.

\section{Verktøy}
Vi endte opp med å bruke en flere verktøy enn beskrevet i  \ref{sec:technologies}. 
I tillegg til hovedverktøyene ble følgende verktøy og teknologier benyttet: 

\subsection{Symfony}
\label{sec:tools-symfony}
Symfony er et webapplikasjonsrammeverk og er et sett med gjenbrukbare komponenter og biblioteker skrevet i PHP \cite{symfony19wis}. 

\subsection{GNU/Linux}
GNU/Linux er en familie med Unix-lignende operativsystemer som baserer seg på Linux-kjernen \cite{kernel_org} og en del programvare fra GNU-prosjektet \cite{gnu_org}. I denne familien finner vi blant annet Ubuntu, Debian, Fedora, Red Hat Linux og Arch Linux.

\subsection{Nginx}
Nginx er en gratis HTTP-server med åpen kildekode \cite{nedelcu2010nginx}. Nginx har mulighet til å håndtere høy belastning av HTTP-forespørsler. Programmet er tilgjengelig på operativsystemer som Windows, Mac OS og Solaris. I tillegg er Nginx tilgjengelig på operativsystemer som er basert på GNU/Linux eller BSD.

\subsection{phpMyAdmin}
phpMyAdmin \cite{phpmyadmin2019bmt} er et gratis og webbasert administrasjonsverktøy for MySQL og MariaDB databaser, skrevet i PHP. Med phpMyAdmin kan man lage, endre og slette databaser, tabeller og felter. Annen funksjonalitet kan være å utføre SQL-setninger, administrere nøkler og privilegier og eksportere data til ulike formater.

\subsection{MariaDB}
MariaDB \cite{mariadb2019amd} er et relasjonsdatabasesystem basert på MySQL og har åpen kildekode. Systemet funker som en \textit{drop-in} erstatning for MySQL.

\subsection{Buddy}
Buddy \cite{buddy2019das} er en webbasert applikasjon for CI og CD. Applikasjonen lar utviklere bygge, teste og distribuere nettsider og programkode automatisk når kildekoden oppdateres. For eksempel er det mulig å koble Buddy til et nettsteds kildekode via Git. Når koden til nettstedet oppdateres, vil Buddy automatisk detektere endringer og starte en byggeprosess. Når byggeprosessen er ferdig kjøres det automatisk tester på koden, som verifiserer at alt fungerer. Deretter vil Buddy laste koden opp til en server og oppdatere nettstedet som ligger ute på nett. Dette skjer gjerne gjennom Docker\footnote{\url{https://www.docker.com/}} sammen med Kubernetes\footnote{\url{https://kubernetes.io/}}.

\subsection{Ottomatik.io}
Ottomatik er en webbasert tjeneste for automatisk sikkerhetskopiering av filer og MySQL databaser \cite{barnes2016osb}.

\subsection{Amazon S3}
Amazon Simple Storage Service er en webbasert tjeneste som tilbyr objekt-lagring \cite{aws2019as3}. Tjenesten tilbyr meget god skalerbarhet, datatilgjengelighet, sikkerhet og ytelse \cite{garfinkel2007aeagcs}.

\subsection{Let’s Encrypt}
Let’s Encrypt \cite{le2019ale} er en gratis og åpen sertifikatautoritet som gir ut X.509-sertifikater for kryptering av transportlaget. Tjenesten leveres av ISRG (Internet Security Research Group).


\subsection{Node.js}
Node.js er et gratis åpen kildekode servermiljø, som kjører på ulike plattformer (Windows, Linux, Unix, Mac OS X) og bruker JavaScript på serveren \cite{w3schools2019win}. Node.js kan generere dynamisk sideinnhold og opprette, åpne, lese, skrive, slette og lukke filer på serveren. I tillegg kan Node.js legge til, slette og endre data i databasen.


\section{Tilhørende teknologier og begreper}
Ved å bruke disse verktøyene som har blitt presentert vil man i tillegg benytte seg av noen tilhørende teknologier. Disse blir presentert videre i dette kapittelet.

\subsubsection{CI \& CD}
CI står for continuous integration og CD står for continuous delivery. CI/CD\cite{Pittet2019cd} er en metode som lar utviklere implementere og levere kodeendringer raskt og pålitelig.

\subsubsection{Sesjoner}
En sesjon\cite{progress2017ohs}(session) er en samling av data lagret på en webserver. En webserver tildeler en ID til hver bruker som sender forespørsler via en nettleser. ID-en lagres som informasjonskapsler i nettleseren til brukeren. Alle nye forespørsel vil så identifiseres av ID-en som er lagret hos brukeren.

\subsubsection{Git}
Git\cite{TechTarget} er et system for versjonskontroll. Et versjonskontrollsystem blir hovedsaklig brukt under utvikling av software og nettsteder. Det kan også brukes til andre type prosjekter som grafisk design og skriving av dokumenter.

Ved å bruke Git opprettes det historikk over alle endringer, samt en sikkerhetskopi av alle versjoner av filene.

En annen fordel ved å bruke Git er at det blir enklere å samarbeide med andre, uten å måtte tenke på at alle må sitte på nyeste versjon av filene.

\subsubsection{Github}
GitHub.com er et nettsted for å hoste git repositories, og blir mye brukt for \q{Open Source}-prosjekter. 

Github\cite{TechTarget} er et sentralisert punkt for å samle en brukers repositories. Ved siden av å hoste repositories, lar GitHub brukere dele repositories med hverandre, lage informasjonssider om prosjektet og opprette saker (issues).

\subsubsection{HTTP/2}
HTTP/2\cite{Belshe2015httpv} er en revisjon av HTTP-nettverksprotokollen. HTTP er et sett med regler for overføring av filer (tekst, grafiske bilder, lyd, video og andre mediefiler). Et av de store målene med HTTP/2 var å tillate multipleksing.

\subsubsection{REST-API}
Et API (programmeringsgrensesnitt) er et sett med funksjoner, prosedyrer, metoder eller klasser som brukes av dataprogrammer for å be om tjenester fra operativsystemet eller programvare som er på datamaskinen. En programmerer kan bruke API-er til å lage applikasjoner.

REST (Representational State Transfer) er en arkitektonisk stil for programvare. Et REST-API\cite{Masse2011radr} er et API som følger REST-stilen og de begrensninger som REST definerer.

\subsubsection{Google Analytics}
\label{sec:google-analytics}
Google Analytics \cite{google2019gtk} er en gratis, webbasert tjeneste som gir statistikk og grunnleggende verktøy for analyse av bruksdata, søkemotoroptimalisering og markedsføring.

\section{Utviklingen}

Det ble opprettet en \q{Branch protection rule} på front- og back-end repositoriene i Github. Dette gjør at det må kjøres en "Code review" før kode kan sendes inn til "Master" branch-en. Alle medlemmene på studengruppen har en egen branch.
Når koden skal comittes må det opprettes en pull request, som må godkjennes. Da blir det mulig å luke ut kode som inneholder feil som potensielt kan ødelegge eksisterende kode.

\section{Back-end dokumentasjon}
Back-end har blitt gjennomført av Bereket og Bjørnar. 

\subsection{Installasjon}
Hele prosessen ble startet ved å laste ned Laravel, XAMPP og Gitkraken. Klonet deretter repositoren som ble opprettet tidligere i Github.

\subsection{Database}
Opprettet en database til prosjektet på phpMyAdmin og satt inn databasen og innloggings-informasjonen i konfigurasjonsfilen .env. Deretter ble det laget modeller for databasen. Modellene lages ved å skrive koden under i kommandolinjevindu: 
\begin{lstlisting}[language=PHP]
    Php artisan make:model Modelnavn -m
\end{lstlisting}  
Det siste “-m” brukes for å opprette migrasjon for modellen  samtidig som den opprettes. Det er også mulig å opprette migrasjon i ettertid: 
 \begin{lstlisting}[language=PHP]
    Php artisan make:migration tabellnavn.
\end{lstlisting}
Etter at modellene og migrasjonene er på plass kan det lages felter på tabellene og deretter kjøre migrasjon for å legge til tabellene til phpMyAdmin. Det er mulig å legge til migrasjonene i phpMyAdmin ved å kjøre koden under i kommandolinjevindu:
\begin{lstlisting}
 php artisan migrate 
\end{lstlisting}

AppServiceProvider defualtlength satt til varchar(255). Dette gjøres for å bestemme lengden på strengen.

Oppretting av  attributter på tabellene gjøres slik: 
\begin{lstlisting}[language=PHP]
    $table->type('atributtnavn');
\end{lstlisting}

Brukte UUID som primærnøkler på de fleste tabellene. UUID (Universally unique identifier)\cite{kilroy2017agulm} er en ID som kan gis til tabellrader for å identifisere dem på en måte som er litt finere enn et sekvensielt tabell-ID. Dette gjør det mulig å ha større tabellrad enn å bruke integer increments.

\subsection{Feil under migrasjon}
Prøvde å ta migrasjon oppsto en feilmelding.
\begin{lstlisting}[language=PHP]
Illuminate\Database\QueryException : SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes (SQL: alter table `users` add unique `users_email_unique`(`email`))
\end{lstlisting}
Årsaken var at datamaskinen har gammel versjon av mysql som ikke støtter standard streng lengde på 255. Da måtte streng lengden endre til 191 og løste feilen.

\subsection{Lage forhold mellom modellene}
Opprettet relasjoner mellom database-modellene. 
Relasjoner  lages ved å bruke  manyToMany,(belongsToMany), One to One(hasOne), Many to One(belongsTo) og  One to Many (hasMany). Eks.  slik  

\begin{lstlisting}[language=PHP]
    $this->hasMany('App\Model') og invers.
\end{lstlisting}

\subsection{Lagringstest til DB}
Etter jeg opprettet ferdig koblingene mellom modellene, tok jeg test for å lagre data på databasen.Testen gjorde på alle tabellene.

\subsection{Feilmeldinger}
\subsubsection{Felt har ikke  standardverdi}
Fremmednøkkel feltet har ikke  standardverdi.

\begin{lstlisting}[language=PHP]
    SQLSTATE[HY000]: General error: 1364 Field 'id' doesn't have a default value (SQL: insert into `fields` (`name`, `slug`, `updated_at`, `created_at`) values (HELLO WORLD, hello_world, 2019-02-06 08:57:48, 2019-02-06 08:57:48))
\end{lstlisting}

Feilen oppsto da fremmednøkkel feltet ble satt til null. Dette løste ved å sette riktig verdien til feltet eller sette fremmednøkkelen til nullable. 

\subsubsection{Data truncated for column}
Vi bruker UUID i stedet increments og trenger å identifisere primærnøkkelen slik.
\begin{lstlisting}
    $table->uuid('id')->primary();
\end{lstlisting}

For å bruke UUID er det viktig å opprette UsesUuid.php trait i App / Trait.
Denne filen brukes til å opprette UUID automatisk når du oppretter nye modeller, deaktivere automatisk increments id-er, sette primærnøkkel som uuid og sette primærnøkkeltype som streng.\cite{medium2019aut} Siden det ikke opprettet UsesUuid.php trait i App/Trait dukket opp feilmelding. 

\begin{lstlisting}[language=PHP]
SQLSTATE[HY000]: General error: 1364 Field 'id' doesn't have a default value (SQL: insert into `fields` (`name`, `slug`, `updated_at`, `created_at`) values (HELLO WORLD, hello_world, 2019-02-06 08:57:48, 2019-02-06 08:57:48))
\end{lstlisting}
Dette betyr at det prøvde å sende UUID verdi i integer.
Dette ble løst med å lage en trait som automatisk lager en UUID når man lagrer modell til DB. (Filsti: /App/Traits/UsesUUID.php).\cite{powery2018euil}
 
\subsubsection{Fremmednøkkel feil}
Feilmeldingen oppsto da det ble prøvd å lagre en bruker på databasen. 

\begin{lstlisting}[language=PHP]
    SQLSTATE[23000]: Integrity constraint violation: 1452 Cannot add or update a child row: a foreign key constraint fails (`sirkus-media`.`users`, CONSTRAINT `users_image_id_foreign` FOREIGN KEY (`image_id`) REFERENCES `images` (`id`)) (SQL: insert into `users` (`name`, `phone`, `email`, `password`, `image_id`, `verified`, `email_token`, `id`, `updated_at`, `created_at`) values (Bere, 4578891, berg@gmail.com, 1234567r, 2432479, 1, e-token, 53f98032-f9bf-40a6-9d70-ca9c0785d7ee, 2019-02-08 10:11:16, 2019-02-08 10:11:16))
\end{lstlisting}

Grunnen var at det ikke går an å sette verdi på en fremmednøkkel felt som verdien ikke finnes på referanse tabellen. Løste ved å sette riktig verdi.

\subsubsection{Fremmednøkkel er ikke satt riktig}
Feilmelding oppsto da migrasjonen utføres. 
Årsaken var at primær og fremmed nøklene satt på ulike type.
Dette betyr at primær nøkkelen blir satt på auto increments og den er unsignedInteger. Da det blir brukt som fremmed nøkkel på en annen tabell burde ha samme type. Dette var satt på integer.
Løste ved å endre typen integer til unsigned integer til fremmednøkkelen. Slik:

\begin{lstlisting}[language=PHP]
    $table->integer('image_size_id')->unsigned();
    $table->foreign('image_size_id')->references('image_size_id')->on('image_sizes');
\end{lstlisting}

\subsubsection{Feilmelding om oppdatering og oppretting kolloner}
\begin{lstlisting}[language=PHP]
    "SQLSTATE[42S22]: Column not found: 1054 Unknown column 'updated_at' in 'field list' (SQL: insert into `image_sizes` (`name`, `max_width`, `max_height`, `id`, `updated_at`, `created_at`) values (size-name, 10, 20, 879d1360-9a74-46f8-b383-ff6ec6e0f387, 2019-02-07 21:08:09, 2019-02-07 21:08:09))
\end{lstlisting}
Grunnen var at timestamps som oppretter opprettings- og oppdateringstiden er automatisk aktivert.
Løste ved å deaktivere den. Slik: 

\begin{lstlisting}[language=PHP]
    public $timestamps = false;
\end{lstlisting}

\subsubsection{Auto Increments feil}
Feilmeldingen sa at fremmednøkkel var ikke satt riktig.
Dette var at auto increments er unsigned integer og brukte bare integer da jeg satte den som fremmednøkkel.
Løste ved å endre integer til UnsignedInteger ved fremmednøkkelen. Slik:

\begin{lstlisting}[language=PHP]
    $table->integer('image_size_id')->unsigned();
    $table->foreign('image_size_id')->references('image_size_id')->on('image_sizes');
\end{lstlisting}

\subsubsection{Forelder/barn fremmednøkkel feil}
Fremmednøkkelen var satt på samme måte som i andre tabeller i et barn tabell. Problemet var at jeg prøvde å lage fremmednøkkel til en tabell som ikke er opprettet enda.
Måtte bryte dette inn i to Schema-blokker, en skaper kolonnene, den andre legger til fremmednøkkel.\cite{meroje2013lmsrfki}
Løste ved å sette fremmednøkkelen på riktig måte. Slik
\begin{lstlisting}[language=PHP]
Schema::create('components', function (Blueprint $table)
       {
           $table->uuid('id')->primary();
           $table->string('name');
           $table->string('slug');
           $table->integer('order');
           $table->uuid('parent_id')->nullable();
           $table->timestamps();
       });
       Schema::table('components', function(Blueprint $table){
           $table->foreign('parent_id')->references('id')->on('components');
       });
\end{lstlisting}

\subsection{Modelkobling test}
Flere fremmednøkkel-felter var satt til nullable som ikke skulle nullable. Startet med å fikse de feltene som skulle ikke ha nullable fremmednøkler.

\subsubsection{Ukjent kolonne feilmelding}
Siden forholdene mellom modellene var ikke satt riktig, oppsto feil under testingen.
\begin{lstlisting}[language=PHP]
"SQLSTATE[42S22]: Column not found: 1054 Unknown column 'links.menu_link_id' in 'where clause' (SQL: select * from links where links.`menu_link_id` = 3 and links.`menu_link_id` is not null) 
\end{lstlisting}
Løste ved å gå gjennom alle modellene og fikse forholdene mellom dem.

\subsection{Roller og Permisjoner}\cite{spatie2019aupar}
Laravel permisjon er en pakke med tillatelser og roller. Dette hjelper brukere til å knytte seg til tillatelser og roller. Hver rolle er knyttet til flere tillatelser. En rolle og en tillatelse er vanlige Eloquent-modeller\cite{oki2017uail}.
\subsubsection{Laravel permisjon pakke installasjon} 
Laravel permisjon pakken er bygget ut over laravel autorisasjon funksjoner\cite{laravelnewsn2017tblp}.
For installere permisjon pakken kjørte composer require spatie/laravel-permission i kommando linje.

\subsubsection{Inkludere pakken på service provider listen}
Inkluderte permisjon pakken på config/app.php. 
\begin{lstlisting}[language=PHP]
    Spatie\Permission\PermissionServiceProvider::class
\end{lstlisting}

\subsubsection{Publisere migrasjonen}
Ved å kjøre koden på kommandolinjen publisere migrasjon filen for permisjon pakken.
\begin{lstlisting}[language=PHP]
   php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider" --tag="migrations" 
\end{lstlisting}

Siden vi bruker uuid som primær nøkkel på user måtte det redigeres permisjon filen. På permisjon filen er satt 'unsignedBigInteger' som standard og burde det  endres  til uuid. Redigeringen gjøres ved å åpne permisjon filen  under 'database/migrations' og erstatte 'unsignedBigInteger' med 'uuid'.
\begin{lstlisting}[language=PHP]
  $table->unsignedBigInteger($columnNames['model_morph_key'])
    Erstatter med 
 $table->uuid($columnNames['model_morph_key'])
\end{lstlisting}

\subsubsection{Publisere konfigurasjonen}
Konfigureringsfilen tillater oss å angi plasseringen av Eloquent-modellen til permisjon og rolle klasse.
For å publisere konfigurasjonsfilen for pakken kjøres koden nede i kommandolinjen.

\begin{lstlisting}[language=PHP]
  php artisan vendor:publish --provider="Spatie\Permission\PermissionServiceProvider" --tag="config"
\end{lstlisting}

\subsubsection{Bygge opp tabeller}
Tok migrasjon slik permisjon tabellene blir bygget på databasen.
Kjørte koden i kommandolinjen.
\begin{lstlisting}[language=PHP]
  php artisan migrate
\end{lstlisting}

\subsection{Lage API}
For å lage api opprettet det først controller\cite{laravel2019c} via cmd terminalen.
Gjøres slik:
\begin{lstlisting}[language=PHP]
    php artisan make:controller PageController --resource
\end{lstlisting}
Den siste parameteren "resource" er et alternativ og kan dropes.

På api.php i routes\cite{laravel2019r}  registrer det API-ruter.
For alle pages:
\begin{lstlisting}[language=PHP]
    Route::get('/pages', 'PageController@index');
\end{lstlisting} 
For en enkel page:
\begin{lstlisting}[language=PHP]
    Route::get('pages/{page}', 'PageController@show');
\end{lstlisting}

\subsection{API Test}
Brukte en verktøy som heter Postman for api test. Postman er en funksjonsrik REST-klient\cite{Rathod2017ITP}. Installerte postman på datamaskinen til å teste api-er. Postman kan installeres her\cite{postman2019tocap}
\subsubsection{Utfordring under testing} 
På mange til mange relasjoner ble  det laget egne modeller på pivot tabellene.
Forholdene ble satt opp via pivot tabellene sine modeller. På kontroller ble det brukt  Apend til å få alle forholdene mellom tabellene. 
\begin{lstlisting}[language=PHP]
    public function menu_links(){
         return $this->hasMany('App\MenuLink')
    }
\end{lstlisting}
Da det ble testet om for eksempel en page ble brukt i menu tabellen via fremmednøkkel, fikk ikke svar.
Fikset ved å sette opp forholdene ved hjelp av 'hasManyThrough'. Gjøres slik:
\begin{lstlisting}[language=PHP]
    public function links(){
         return $this->hasManyThrough(    
            'App\Link',
            'App\MenuLink',
            'menu_id',
            'id',
            'id',
            'link_id'
         );
      }
\end{lstlisting}

\subsection{Sett opp autentisering}
Autentisering brukes til å kontrollere tilgang til ressurser. For å kontrollere tilgang skal nettsiden ha logginn og registreringsside. Registrering siden skal være tilgjengelig for brukere som logget seg inn. 
Lagte autenisering ved å kjøre koden i comandlijen.
\begin{lstlisting}[language=PHP]
    php artisan make:auth 
\end{lstlisting} 
    
I RegisterController kan det endres tilgangen for å opprette nye brukere.
\begin{lstlisting}[language=PHP]
    $this->middleware('guest');
\end{lstlisting}
Endre guest med auth. Dette krever at bruker må logge seg inn for å kunne opprette nye brukere.
\begin{lstlisting}[language=PHP]
    $this->middleware('auth');
\end{lstlisting}

\subsubsection{ Registrering av bruker}
Etter autentiseringen er prøvde det å registrere ny bruker. Det oppsto en feilmelding under registrering av ny bruker
\begin{lstlisting}[language=PHP]
    SQLSTATE[HY000]: General error: 1364 Field 'image_id' doesn't have a default value
\end{lstlisting}  
Løste feilen ved å endre standard verdien til "imageid" feltet i bruker database tabellen. Gjorde slik:

\begin{lstlisting}[language=PHP]
    $table->uuid('image_id')->nullable()->default(null);
\end{lstlisting} 

\subsubsection{Mailtrap}
For en bruker skal logge seg inn kreves det epost bekreftelse.
Fikk feilmelding om mail bekreftelsen.
\begin{lstlisting}[language=PHP]
    Swift_TransportException in AbstractSmtpTransport.php line 383: Expected response code 250 but got code "530", with message "530 5.7.1 Authentication required
\end{lstlisting}
    
Løste feilen ved å lage midlertidig konto i mailtrap.io og fikk bekrefte inloggingen.
Mailtrap\cite{mailtrap2019setfsad} er en falsk SMTP-server for å teste, vise og dele e-postmeldinger sendt fra utviklings- og oppstartsmiljøene uten å spammere virkelige kunder.
I mailtrap under SMTP instillinger finnes det bruker informasjonen og den bør kopieres og limes i .env filen i laravel.

\begin{lstlisting}[language=PHP]
    MAIL_DRIVER=smtp
    MAIL_HOST=smtp.mailtrap.io
    MAIL_PORT=2525
    MAIL_USERNAME=62338a10f2cd0f
    MAIL_PASSWORD=b67a88da87aecc
    MAIL_ENCRYPTION=tls
\end{lstlisting}

\subsection{SEEDS}
For å lage forskjellige bruker roller lagte det RoleSeeder i databasen.
Kjørte koden i kommandolinjen for å opprette det.
\begin{lstlisting}[language=PHP]
    php artisan make:seeder RoleSeeder
\end{lstlisting}
Lagte forskjellige roller i RoleSeederen
\begin{lstlisting}[language=PHP]
    $user = Role::create(['name' => 'user']);
   $moderator = Role::create(['name' => 'moderator']);
   $admin = Role::create(['name' => 'admin']);
   $superadmin = Role::create(['name' => 'superadmin']);
\end{lstlisting}
\subsection{CRUD}       
Opprettet CRUD (Creating, Reading, Updating and Deleting) filer for å opprette, lese oppdatere og slette ressurser. På ressurs kontroller kan skrives logikken om hvordan ressursene opprettes, lagres, leses, oppdateres og slettes. 

\begin{lstlisting}[language=PHP]
    class PageController extends Controller
    {   public function __construct()
       {  $this->middleware('auth'); }
       public function index()
       {   $pages = Page::paginate(30);
           return view('pages.index',compact('pages'));
       }
       public function create()
       {   $pages = Page::All();
           $images = Image::All();
           return view('pages.create', compact('pages','images'));}
       public function store(Request $request)
       {      $request->validate(['title'=>'required|string',
               'image_id'=> 'nullable' ]);
           $page = new Page([
               'title' => $request->get('title'),
               'image_id'=> $request->get('image_id')]);
             $page->save();
             return redirect('/pages')->with('success', 'Page er opprettet'); }
       public function show(Page $page)
       {   $page->menu;
           $components = $page->components;
           foreach($components as $component){
               $component->fields; }
           return view('pages.show',compact('page'));  }
        public function edit($id)
       {   $page = Page::find($id);
           $images = Image::All();
           return view('pages.edit', compact('page', 'images'));
       }
       public function update(Request $request, $id)
       {	   $request->validate(['title'=>'required|string',
               'image_id'=> 'nullable']);
             $page = Page::find($id);
             $page->title = $request->get('title');
             $page->image_id = $request->get('image_id');
             $page->save();
             return redirect('/pages')->with('success', 'Page er oppdatert'); }
       public function destroy($id)
       {   $page = Page::find($id);
           $page->delete();
        return redirect('/pages')->with('success', 'Page er slettet');}}
\end{lstlisting}

Etter det ble ferdig laget med CRUD, testet om det fungerer.
I create.blade.php filen prøvde å lage nedtrekksmeny med komponenter.
Fikk feilmeldingen:
\begin{lstlisting}[language=PHP]
    "Property [component_id] does not exist on this collection instance.
\end{lstlisting}

Grunnen var at det ble hentet flere komponenter fra databasen og prøvde å sette de som en singel komponent.
Løste feilen ved å bruke for løkke.
\begin{lstlisting}[language=PHP]
    @foreach($components as $component)
    <option value="{{$component->id}}" {{old('component_id',component->id)}}? selected> {{$component->name}} </option>
     @endforeach
\end{lstlisting} 

\subsection{Route}
Web.php fil i routes katalogen definerer  ruter  for webgrensesnitt\footnote{\url{https://laravel.com/docs/5.8/routing}}.
Skrives for eksempel slik, hvis man har flere ressurser :
\begin{lstlisting}[language=PHP]
    Route::resources([
        'pages' => 'PageController',
        'components' => 'ComponentController',
        'links' => 'LinkController',
        'fields' => 'FieldController',
        'menus' => 'MenuController'
        ]);
\end{lstlisting}

I tillegg ble det lagte php filer for grensesnitt til ressurser. index.blade.php, create.blade.php, edit.blade.php, og show.blade.php
\cite{savani2018lcrud}

Tilgangene til ressurser kan være forskjellige fra bruker til bruker og gis for eksempel slik via kontrolleren.
\begin{lstlisting}[language=PHP]
    public function __contruct(){
       $this->middleware('auth');
       $this->middleware('role:superadmin');
    }
\end{lstlisting}

Eksemplet viser at tilgangen er gitt bare til brukere med superadmin rolle.

Har lagt linker for Menus og Pages til brukere som er logget seg inn.
Etter linkene ble lagt og rollene blitt gitt fikk ikke det å åpne linkene eller registrere nye brukere. Fikk feilmelding om det ikke eksisterer rolle klasse. 
\begin{lstlisting}[language=PHP]
    "Class App\Http\Spatie\Permission\Models\Role does not exist"
\end{lstlisting}
 
Prøvde å rette feilen ved å legge til rolle klasse i kernel.php slik:
\begin{lstlisting}[language=PHP]
   protected $routeMiddleware = ['role'=>Spatie\Permission\Models\Role::class]; 
\end{lstlisting}  
Løsningen ga en annen feilmelding om klasse rolle ikke finnes
 \begin{lstlisting}[language=PHP]
      "Class 'Role' not found
 \end{lstlisting}

Feilen var at det ble lagt Role modelle klasse istedet Middleware klasse og løste ved å sette riktig Middleware klasse. Middleware \cite{laravel2019mw} er en mekanisme som kan  filtrere http-forespørsler. Den kan for eksempel verifisere en bruker er autentisert. 
\begin{lstlisting}[language=PHP]
   'role' => \Spatie\Permission\Middlewares\RoleMiddleware::class,
\end{lstlisting}

Registering av en ny bruker gikk men fikk feilmelding samtidig.
\begin{lstlisting}[language=PHP]
   "Argument 1 passed to Illuminate\Auth\SessionGuard::login() must implement interface Illuminate\Contracts\Auth\Authenticatable, null given,
\end{lstlisting}

Feilen var at den prøver å sende den registrert brukeren til en side mens en annen  bruker er logget seg inn på siden. Registrering av en ny bruker gjennomføres av innlogget brukere med admin rettigheter.

Løste ved å overskrive og slette koden som sender brukeren til siden. Slik:
\begin{lstlisting}[language=PHP]
   public function register(Request $request)
       {
           $this->validator($request->all())->validate();
    
           event(new Registered($user = $this->create($request->all())));
    
        Sletter dette linje
            $this->guard('web')->login($user);
    
           return $this->registered($request, $user)?: redirect($this->redirectPath());
       }
\end{lstlisting}
  
\cite{spatie2019aupar}  
\clearpage



\input{bjornar/kladd}

\section{Front-end}
Front-end ble i hovedsak gjort av Line, med god hjelp av Bjørnar. 

\subsection{Oppsett av React og tilhørende verktøy}

Det første som ble gjort i denne prosessen var å laste ned Node.js\footnote{\url{https://nodejs.org/en/}}. I dette prosjektet blir ikke Node brukt som en back-end tjenester eller server, men for å kunne kjøre alle verktøy som må til for å kunne utvikle lokalt på datamaskinen. Det var den nyeste versjonen (11.9.0) som ble lastet ned. Deretter ble nettleserutvidelsen React Developer Tools lagt til fra  webstoren til Google Chrome. Det ble også opprettet et repository på Github og lastet ned på maskinen ved hjelp av GitKraken. 
Videre var det nødvendig med et kommandolinjevindu og en teksteditor, valget falt da på kommandolinjevinduet Powershell og teksteditoren Visual Studio Code.

For å sette opp selve React, ble  guiden til react.org for å sette opp en ny React App\footnote{\url{https://reactjs.org/docs/create-a-new-react-app.html\#create-react-app}} fulgt. Her ble det oppgitt at følgende kommandoer må kjøres for å opprette et nytt prosjekt:
\begin{lstlisting}
npx create-react-app my-app
cd my-app
npm start
\end{lstlisting}

Det oppstod problemer når kommandoen \q{npx create-react-app my-app} skulle kjøres, og det kom flere og lange feilmeldinger. Dette måtte undersøkes nærmere, og etter et Google-søk på deler av feilmeldingen ble det oppdaget en sak på Github som omhandlet samme problem\footnote{\url{https://github.com/facebook/react/issues/11933}}.
Løsningen var å installere yarn og create-react-app globalt med yarn. La så til følgende i windows PATH så kommandoen kunne kjøres:
\begin{lstlisting}
C:\\Users\Datahjelpen AS\AppData\Local\Yarn\bin
\end{lstlisting}
Dette løste problemet og prosessen kunne fortsette. Da ble følgende gjort:

\begin{itemize}
\item Kjørte \q{npm install} i mappen for prosjektet.
\item Kjørte \q{npm start} for å starte react serveren.
\end{itemize}

Etter disse stegene begynte planleggingen av de forskjellige komponentene.

\section{Planlegging av komponenter}
Komponenter i React kan beskrives som gjenbrukbare biter av kode. En stor fordel med komponenter er at de er mulig å gjenbruke, slik at det ikke lenger er nødvendig å skrive den samme koden flere ganger. 

Ved å se på den godkjente mockupen ble følgende komponenter fastsatt: 
\begin{itemize}
\item Meny
\item Header
\item Resultater
\item Prosess
\item Steg i prosess
\item Kontaktskjema
\item Footer
\item Ikon + link
\item Ikon + tekst
\item Hvit boks under header. ActionBox
\item Actions til actionsbox
\end{itemize}

\section{Oppretting av components}
Prosessen med oppretting av komponenter startet med å lage en samlemappe som ble kalt \q{components}, som ligger i mappen src. For hver komponent ble det laget en ny undermappe som inneholdt koden til selve komponenten og eventuelt tilhørende stilark.

\section{Ruting (Routing)}
Ruting er et mønstergjenkjenningssystem som tar seg av innkommende forespørsler og sender de til spesifikke kontroller-funksjon. Ruting er ikke innebygd i React. Det ble derfor laget en Router.js-fil i components-mappa. Etter dette ble følgende kommando kjørt:

\begin{lstlisting}
npm install react-router-dom
\end{lstlisting}

Importerte deretter react-router-dom i filen Router.js

\begin{lstlisting}
import {BrowserRouter, Route, Switch} from "react-router-dom";
\end{lstlisting}

Den foreløpige versjonen av back-end ble lastet ned og lagret lokalt, slik at det ble mulig å teste underveis.

For å kunne snakke og bruke foreløpig backend ble Axios\footnote{Se mer i avsnitt \ref{sec:tool:axios}} benyttet. Hvis etableringen av forbindelsen er vellykket, slik at det har blitt opprettet kontakt med databasen via Axios, vil alle svar som ble gitt av back-end bli lagret i en array. 

Deretter ble det satt opp en dynamisk ruting, ved hjelp av en løkke som går igjennom alle eksisterende sider og setter opp linker til disse.

\subsection{Installering av Axios}
Axios blir i vårt system brukt til å sende forespørsler til back-end. Dette biblioteket ble installert ved å kjøre kommandoen under.  Kommandolinjevindu må åpnes i filstilen der mappa til prosjektet er plassert.
\begin{lstlisting}
npm install axios
\end{lstlisting}


\subsection{Page components}

Det ble opprettet et objekt som inneholder alle komponentene som er definert i databasen. Ved å loope igjennom alle komponentene til en side, ble det da mulig å sjekke om navnene samsvarte. Hvis de gjorde dette vil det kjøres en løkke som går igjennom alle feltene en komponent inneholder. Til slutt blir alle komponentene til en side, med riktige props\footnote{Props i React brukes til å sende med utvalgt data til en komponent} skrevet ut.  

Før det ble opprettet et objekt som inneholdt alle eksisterende components, ble det forsøkt å kun hente ut angitt komponenter til siden i back-end og så opprette components ut av dette. Da fikk vi følgende feil:
\begin{lstlisting}
<HeaderComponent /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.
\end{lstlisting}

Feilmeldingen var at komponenten brukte feil casing, noe som ikke var riktig da man i feilmeldingen også kunne se at \q{\textless HeaderComponent /\textgreater} er skrevet på riktig måte. Etter en del feilsøking, fant vi ingen som hadde løst dette problemet tidligere. Endte derfor opp med å opprette objektet som inneholder alle komponentene. 

I tillegg til å finne ut av hvilke komponenter som tilhører siden, må man i tillegg finne ut av hvilke felter som tilhører hvilke komponenter. Dette blir satt i back-end. I løkka som går igjennom objektene ble det derfor lagt til en ny løkke, som går igjennom og lagrer alle tilhørende felter til en komponent i en array. Denne arrayen blir så sendt videre som props i de ulike komponentene.

\subsection{Child components}
I systemet vårt kan et komponent ha flere \q{barn}. Det å ha komponenter som er barn av en komponent gjør at disse har et forhold til hverandre. Da blir det mulig å putte forskjellig innhold inn i en felles seksjon.

\subsection{Felter med samme navn}
Underveis i prosessen ble det oppdaget at hvis en komponent hadde den samme felttypen flere ganger, ville bare den siste verdien bli skrevet ut. En komponent vil ofte bestå av for eksempel flere tekstfelt, og derfor måtte vi finne en måte å løse dette på.

Løsningen ble en betingelsetest der det blir sjekket om samme felttype er til stede flere ganger. Hvis denne blir sann, vil feltene med verdier bli lagt til i en array. 

\subsection{Utskrift av tomme felter}
Videre i prosessen ble det oppdaget at hvis en prop ikke innholdt en verdi, ville feltet fortsatt bli skrevet ut. Dette førte til at nettstedet inneholdt mange tomme HTML-tagger. Brukervennligheten på for eksempel skjermlesere hadde blitt betraktelig dårligere, så derfor måtte dette gjøres om. Løsningen ble å gjøre en betingelse-test på hver prop, for å sjekke om den innholdt en verdi. Da ble det mulig å kun skrive ut om dette var oppfylt.

\subsection{Testing}
For å teste systemet ble header-komponenten laget. Når denne ble opprettet både i objektet og back-end, ble alle props/feltene som blir mottatt fra komponenten skrevet ut. Dette betydde at Header-komponenten fungerte som den skulle, og vi kunne starte med å legge til resten av komponentene på den samme måten. 

Da kunne vi også begynne å style slik komponentene slik at de ligner mockupen som ble laget.

\subsection{Kompilere SCSS til CSS}
Gruppen har tidligere nevnt at det ble besluttet å bruke SASS til styling. Da er det nødvendig å ha noe som kompilerer fra SCSS til CSS. Dette ble oppnådd ved å følge guiden hos TechCookbook\footnote{\url{https://techcookbook.com/react/use-scss-with-create-react-app}}

Lastet først inn node-sass ved å kjøre :

\begin{lstlisting}
npm install --save node-sass
\end{lstlisting}

Etter at pakken ble installert, måtte det lages et script som kompilerer fra .scss til .css:

\begin{lstlisting}
 "build-css": "node-sass src/ -o src/"
\end{lstlisting}
\clearpage

\q{Build-css} tar .scss-filene som finnes i source-mappen samt undermapper og kompilerer dem til .css-filer. .css filen vil bli tilgjengelig i den samme lokasjonen som den originale .scss-filen. Deretter ble det laget et script som kjører \q{build-css} og kompilerer alle eksisterende filer til .css, samtidig som den ser etter forandringer i source-mappen. Den vil altså detektere om det blir gjort endringer i eksisterende .scss filer, eller om det blir lagt til nye. 

\begin{lstlisting}
 "watch-css": "npm run build-css && node-sass src/ -o src/ --watch --recursive"
\end{lstlisting}

En test ble gjort ved å lage en fil som het "header.scss" og satte bakgrunnsfargen til rød. Dette fungerte som det skulle.

\begin{lstlisting}
 body {
  background-color: red;
}
\end{lstlisting}

\section{Styling}
Designet til nettstedet ble stylet ved hjelp av SCSS, og er så lik den godkjente mockupen som mulig. Designet er også responsivt og fungerer derfor like godt på en stor skjem, laptop, nettbrett og mobil.


% \section{Utredning}

% \meta{
% Det er mulig at dette kapitellet er overflødig i et utredningsprosjekt. Utredningen er jo et eget dokument, og trenger vel ikke med kontekst for å kunne evalueres.
% }

% \section{Mediaproduksjon}

% \meta{
% For denne typen prosjekter kan det være relevant å beskrive og rapportere fra selve produksjonen. Det er vel relativt vanlig at man må endre og improvisere i forhold til opprinnelig plan, og det bør jo absolutt dokumenteres, ikke minst i forhold til diskusjonen (Kapittel 6.2). er mulig at dette kapitellet er overflødig i et utredningsprosjekt. Utredningen er jo et eget dokument, og trenger vel ikke med kontekst for å kunne evalueres.
% }

% \section{OpenOffice Writer}

% Se vedlegg i rapporten {\em OpenOffice mal for hovedprosjektrapport}.

% \section{\LaTeX}

% For et nærmere innblikk i hvordan denne malen er implementert, se kildekoden som følger med.
% Resultatet av den ønskede layout kan selvfølgelig sees i dokumentet du leser nå, eller i mer formell form i Figur \ref{fig:layout1}.


% \begin{figure} 
% \index{Recto} 
% \printinunitsof{mm}
% \currentpage
% \oddpagelayouttrue
% %\oddpagelayoutfalse 
% %\twocolumnlayouttrue 
% \pagediagram 
% %\drawpage
% %\pagedesign
% \center
% \setvaluestextsize{\scriptsize}
% \pagevalues
% \caption{Layout for recto sider} 
% \label{fig:layout1} 
% \end{figure}
